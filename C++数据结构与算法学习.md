# 《C++数据结构与算法 第4版》

## 1.C++面向对象程序设计
**关键字**：<font color=#0099ff size=3 face="黑体">抽象数据类型</font>（对象、类）、<font color=#0099ff size=3 face="黑体">封装</font>（类、模板类、模板函数、赋值运算符重载）、<font color=#0099ff size=3 face="黑体">继承</font>（基类、虚基类）、<font color=#0099ff size=3 face="黑体">标准模板库</font>

<font color=#ff99ff size=3 face="黑体">抽象数据类型</font>
1) C++类中`protected`关键字的作用：基类的保护成员可以在派生类的成员函数中被访问
2) C++类继承时使用`virtual`关键字：表示虚基类继承方式，子类只是基类的一个副本，主要用于多重继承中防止最终的子类函数存在二义性问题，而最终的子类将只含有一个基类。
3) 内存泄漏问题：合理使用new和delete进行解决
   ```
   //内存泄漏案例
   p = new int;v
   p = new int;
   ```
   对p二次分配内存，导致第一次分配的内存在程序运行期间无法访问且不能再次分配，出现内存泄露问题。正确做法是：
   ```
   //内存泄漏的解决
   p = new int;
   delete p;
   p = new int;
   ```
   **Tips**：delete只应该用于使用new赋值的指针
4) 复制构造函数，防止不同实例间赋值时的相互影响。例：`Node(const Node&)`
5) 重载赋值运算符：`Node operator=(const Node& n) {xxx}`
6) 指针、引用变量和引用返回类型，一个有趣的例子：
   ```
   #include <iostream>
   using namespace std;
   class C {
     public:
         int & getRefN(){  //引用返回类型
           return n;
         }
         int getN(){
           return n;
         }
     private:
         int n;
   } c;
   int main()
   {
   int &k = c.getRefN();
   k = 7;
   cout << c.getN();
   return 0;
   }
   ```
   不合理的使用引用返回类型，导致类中的私有成员可以被非类成员函数修改值，破坏了信息隐藏原则。

7) 函数指针：函数的地址指明了函数体在内存中的位置，函数指针一般用于函数作为形参的情况。

8) 多态性(OOP):同样的函数名称表示多个函数，而且这些函数是不同对象的成员。利用这一特性可以将一个标准消息发送至许多不同的对象，而不需要指定如何处理消息，也不需要知道对象是什么类型。

9) 友元函数：可以让有些用户访问信息的私有部分。

10) 标准模板库：容器、迭代器和算法
    + 容器：deque、list、map、multimap、set、multiset、stack、queue、priority_queue、vector
    + 迭代器：通用指针，用于引用存储在容器中的元素
    + 算法：STL提供了大概70个通用函数，称为算法，主要针对容器进行操作：在容器中定位元素、插入元素、删除元素、修改元素、比较元素、元素排序
    + 函数对象的使用。可与模板函数相结合

## 2.复杂度分析
1) 计算复杂度与渐进复杂度
2) 渐进复杂度的衡量：大O表示法，记号`O(n)`表示阶数与n相关但没有超过n的量级，通常表示函数的上界---->$f(n)=O(g(n))$
   <font color=#0099ff size=3 face="黑体">大O表示法的定义：</font>若存在正数c和N，对于所有的$n \geq N$,有$f(n) \leq cg(n)$，则$f(n)=O(g(n))$
3) 大O表示法的性质：
   + 传递性：若法$f(n)=O(g(n)),g(n)=O(h(n))$，则$f(n)=O(h(n))$
   + 若法$f(n)=O(h(n)),g(n)=O(h(n))$，则$f(n)+g(n)=O(h(n))$
   + $an^k=O(n^k)$
   + 对任何正数$j$，$n^k=O(n^{k+j})$
   + 如果$f(n)=cg(n)$，则$f(n)=O(g(n))$
   + 对于任何的正数a和b($b \neq 1$)，则$log_{\tiny{a}}n=O(log_{\tiny{b}}n)$，该条性质表明所有对数函数都有相同的增长速度，进一步推出下一条的性质
   + 对于任何正数$a \neq 1$，$log_{\tiny{a}}n=O(lg\,n)$，其中$lg\,n=log_{\tiny{2}}n$
4) $\Omega$表示法与$\Theta$表示法
   + $\Omega$表示法,表示函数的下界，<font color=#0099ff size=3 face="黑体">$\Omega$表示法的定义：</font>若存在正数c和N，对于所有的$n \geq N$,有$f(n) \geq cg(n)$，则$f(n)=\Omega(g(n))$
   + $\Theta$表示法,<font color=#0099ff size=3 face="黑体">$\Theta$表示法的定义：</font>若存在正数$c_1,c_2$和N，对于所有的$n \geq N$,有$c_1g(n) \leq f(n) \leq c_2g(n)$，则$f(n)=\Theta(g(n))$
5) 确定渐进复杂度
   对时间复杂度进行分析：计算程序执行过程中赋值和比较操作的次数。常见的分析有：
   + 对最好、最坏、平均情况的分析。
   + 摊销复杂度分析：主要是针对操作序列进行分析
6) 复杂度从小到大排序：`O(1) -> O(lg n) -> O(n lg n) -> O(n^2) -> O(n^3) -> O(n^k) -> O(k^n) -> O(n!)`

## 链表
链表与数组的对比：
+ 数组在编译期要知道大小
+ 数组中的数据在计算机内存中是以相同距离间隔开的，插入数据比较麻烦
+ 链表不存在以上两点问题
+ 数组可以直接访问其中元素，链表需要进行遍历访问
+ 空间开销不同

1) 单向链表：序列中的节点只包含指向后继节点的链接
   + 构成：节点类和链表类
   + 链表的操作：构造函数、在头部添加节点、在尾部添加、从头部删除、从尾部删除、删除节点、是否存在链表中
   + **一点认识：**`head`和`tail`直接指向节点，即可以直接访问指向的节点
   + 时间复杂度分析：在头部、尾部添加节点的时间复杂度为：$O(1)$

<font color=#0099ff size=3 face="黑体">知识点：</font>释放指针指向的内存空间，正确的操作包括两步：
```
type *ptr = new typeClass();  

释放ptr指针；
delete ptr; //第一步释放ptr指向的内存空间
ptr = 0;  //第二步将指针设置为空指针，防止对第一步释放的内存空间产生误操作
```

2) 双向链表：链表中的每个节点有两个指针，一个指向前驱，一个指向后继

3) 循环链表：节点组成一个环，链表长度有限，每个节点都有后继节点。--->循环双链表
4) 跳跃链表（skip list）：解决链表查找时需要顺序进行扫描的问题。按照链表中节点的个数，决定链表中的节点包含不同个数的指针。主要提升链表查找效率，但插入和删除效率变低。理想情况的查找时间为$O(lgn)$，最坏情况与单向链表相同为$O(n)$。
5) 自组织链表：为了提高查找效率
6) 稀疏表：为了提高空间利用率，可以使用链表替代稀疏表

7) 标准模板库中的链表： `#include<list>`

## 栈与队列

1) 基础知识
+ 栈：线性数据结构，LIFO，可使用vector可变数组或者链表实现。
  常用方法：`clear(),isEmpty(),push(),pop(),topEl()`
+ 队列：FIFO，常用方法：`clear(),isEmpty(),enqueue(),dequeue(),firstEl()`，可用数组或双向链表实现
+ 优先队列：Priority Queue，实现思路：①使用无序链表，则插入时立即，取出时O(n);②使用有序链表，则插入时O(n)，取出时立即
+ 标准库中的栈stack：stack可以选择底层实现:双端队列（默认deque容器）、向量、链表
+ 标准库中的队列queue：默认为deque容器实现，也可用list容器实现
+ 标准库中优先队列priority_queue：默认使用vector容器实现
+ 标准库中的双端队列dequeue(double-ended queue)：允许两端访问的线性表.STL的实现为指针数组，指向块或者数据数组

2) 迷宫问题--[栈+回溯法](https://blog.csdn.net/sssssuuuuu666/article/details/78767824)----[reference](https://wenku.baidu.com/view/f5f22f2349649b6649d7476f.html)


## 递归

1) 递归定义：分为两部分，第一部分为基例，列出产生集合中其他元素的基本元素，第二部分给出由基本元素或已有对象产生新对象的构造规则。
2) 函数调用和递归实现：通过运行时栈记录函数活动（参数和局部变量、返回值、返回地址等），系统可以正常处理递归，递归调用只是一个函数实例调用同一函数的另一个实例。
3) 递归与循环相比更接近问题的原始定义，且实现程序通常更加简洁。
4) 常见的递归：
   + 尾递归：在每个函数的实现末尾只使用一个递归调用，且之前没有直接或间接的递归调用。
   + 非尾递归：函数中存在多个递归调用
   + 间接递归：直接递归是函数直接调用自身，间接递归是指函数通过一系列其他操作来间接地调用自身
   + 嵌套递归
5) 不合理递归：递归的优点是逻辑上的简单和可读性强，缺点是降低了运行速度

6) 八皇后问题：递归+回溯
   

## 二叉树
1) 二叉树的实现
   + 使用数组
   + 使用链式结构实现（类似链表的实现）
2) 二叉查找树的特性：对于节点n，其左节点中的值小于节点n的值，其右节点中的值大于节点n的值。
3) 二叉查找树的相关操作：
   + 实现：链式结构实现
   + 查找：时间复杂度：$O(lgn) \sim O(n)$
   + 遍历：当且仅当访问树中每个节点一次的过程。遍历方式有：中序遍历（LVR）、前序遍历（VLR)和后续遍历（LRV)
4) 二叉树遍历常用方法：
+ 广度优先遍历（可以从上到下，从左到右）
+ 深度优先遍历(基于栈实现)，存在多种遍历顺序，可以使用递归实现深度优先遍历
  ```
  //三种不同顺序的深度优先遍历--递归实现
  templete<class T>  //中序树遍历
  void BST<T>::inorder(BSTNode<T> *p) {
    if (p != 0)
    {
      inorder(p->left);
      visit(p);
      inorder(p->right);
    }
  }

  templete<class T>  //前序树遍历
  void BST<T>::preorder(BSTNode<T> *p) {
    if (p != 0)
    {
      visit(p);
      preorder(p->left);
      preorder(p->right);
    }
  }

  templete<class T>  //后续树遍历
  void BST<T>::postorder(BSTNode<T> *p) {
    if (p != 0)
    {
      postorder(p->left);
      postorder(p->right);
      visit(p);
    }
  }
  ```
  使用非递归实现上述前序树的遍历（使用栈+迭代）：
  ```
  templete<class T>
  void BST<T>::iterativePreorder() {
    Stack<BSTNode<T>*> traveStack;
    BSTNode<T> *p = root;
    if(p != 0) {
      traveStack.push(p);
      while(!traveStack.empty()) {
        p = traveStack.pop();
        visit(p);
        if(p->right != 0 )
            traveStack.push(p->right);
        if(p->left != 0)
            traveStack.push(p->left);
      }
    }
  }
  ```

+ 深度优先遍历（不使用栈）：①线索树:线索算法②通过树的转换进行遍历：Morris算法

结果对比：四类树遍历方法：递归、迭代、线索算法、Morris算法，时间复杂度均为$O(n)$，空间消耗上只有Morris算法不需要额外的空间消耗，其他三种算法都需要$O(n)$额外空间消耗。

5) 二叉遍历树的插入：在扫描树的过程中，将插入值和当前节点进行比价，如果插入值小于当前节点，就测试当前节点的左节点，反之测试右节点。如果测试的节点为空，则停止扫描，插入值将成为该节点的子节点。

6) 删除：根据被删除节点的情况分类讨论：被删除节点是叶节点、被删除节点仅有一个子节点、被删除节点有两个子节点（合并删除、复制删除）。

7) 树的平衡:如果树中任意节点的两个子树的高度差为0或1，则该树是平衡的。
   平衡方法：①对所有元素进行排序后在构造平衡树，指定中间元素为根节点；②DSW算法

8) 堆：一种特殊类型的二叉树，满足如下性质：①每个节点的值大于（小于）等于子节点的值--大顶堆（小顶堆）；②完全平衡，且最有一层叶节点位于左侧。
  非常适合用于实现优先队列。


## 多叉树--多用于表示层次关系
### 1.B树家族：B树、B*树、$\mathbf{B^+}$树、前缀$\mathbf{B^+}$树、k-d B树、位树、R树、2-4树（红黑树）
1.1 B树
应用场景：
+ 数据库程序，磁盘存储快速读写，用于操作辅助存储器
+ $\mathbf{B^+}$树常常用来实现关系型数据库的索引，可以提供非常快速的随机数据访问，以及快速的顺序数据处理。
B树的操作：查找、插入、删除键值......

1.2 标准模板库中的集合（set）和多重集合（multiset）--红-黑树实现
set容器是一个存储有序唯一元素的数据结构，为了加速插入（删除）操作的执行，STL使用红-黑树来实现容器set，保证插入和删除操作需要的时间为$O(lg\, n)$，但会减弱容器set的灵活性。

1.3 标准模板库中的映射（map）和多重映射（multimap）--红-黑树实现
映射是可以用任何类型的数据作为索引的表，映射可以看成还是广义的set。

### 2.trie--用键值的一部分来确定查找路径的树称为trie
应用场景：拼写检查器


## 图
<font color=#0099ff size=3 face="黑体">树和图特点的对比：</font>树存在只能表示层次关系的局限性，其他关系只能简介表示，图是树的推广。图是由顶点或节点及顶点间的关系组成的集合。
常见图的种类：简单图、完全图、多重图、伪图、加权图

1.图的表示方法
+ 邻接表
+ 邻接矩阵
+ 关联矩阵

2. 图的遍历
   深度优先搜寻和广度优先搜索方法两种。

3. 最短路径的求解：Dijkstra算法、Ford算法
   多源多目标最短路径：Floyed算法

4. 环的检测：基于DFS算法的修改
5. 生成树：最小生成树，用于求解多个节点之间的最短路径问题，Kruskal算法
6. 连通性：无向图和有向图的连通性

### 网络
网络是图的一种重要类型。网络是有向图，有一个源点s和一个汇入点t，源点没有输入边，汇入点没有输出边。


## 排序
1.基本排序算法
+ 插入排序：时间复杂度：$O(n^2)$，优点：只有需要时才会对数组进行排序
+ 选择排序：时间复杂度：$O(n^2)$，优点：赋值次数少，交换次数都为3(n-1)
+ 冒泡排序：时间复杂度：$O(n^2)$，冒泡排序的次数近似为插入排序的两倍，移动次数与插入排序一样；冒泡排序与选择排序的比较次数是一样的，移动次数比选择排序多出n次。
+ 梳排序：改良自冒泡排序和快速排序，尽量把小的数字往前移动并保证此次间隔内的组是有序的。时间复杂度：$O(nlog\,n)$

2. 决策树
   弧的平均数反映了排序算法关键字比较的平均次数。

3. 高效的排序算法
   希尔排序、堆排序、快速排序（最好的排序算法，不适合小型数组）、归并排序、基数排序、计数排序（可以基数排序结合使用）
4. STL中的排序算法
   在`<algorithm>`中


## 散列
1. 散列函数：函数$h$可以将特定关键字的值转换成表的一个索引，该表用于存储和关键字值类型一样的项，这个函数$h$称为散列函数。又称为哈希函数。
2. 散列表，又称为哈希表，实现数据内容和存储地址之间的映射。常用的散列函数有：除余法、折叠法、平方取中法、提取法、基数转换法、全域散列法等。

## 数据压缩
压缩条件、压缩率、压缩编码方式：Huffman编码、Run-Length编码

## 内存管理
1. 堆：主内存区域，其中的部分内存可以根据程序的请求进行动态内存分配。
内存分配相关的函数:C: malloc()、free C++:new()、delete()
2. 垃圾回收机制：分为标记阶段和重新声明阶段。
3. 案例分析：in-place垃圾回收器的实现。

## 字符串的匹配
1. 精确匹配
   在文本T中找出模式P的精确副本。

2. 案例分析
   查找最长公共子字符串


$$
f(n) = 
\begin{cases} 
0 & n = 0 \\
1 & n = 1 \\
f(n-1)+f(n-2) & n > 1
\end{cases}
$$

$$
\begin{matrix}
I_{3\times3}& -[^0t_e]_{\times}\\ 
0_{3\times3}& I_{3\times3}
\end{matrix} ^0{\boldsymbol{J}}^v
$$

$\begin{vmatrix}
 I_{3\times3}& -[^0t_e]_{\times}\\ 
0_{3\times3}& I_{3\times3} 
\end{vmatrix}$

$$\begin{bmatrix}
f(n)& f(n-1)\\ 
f(n-1)& f(n-2)
\end{bmatrix}  =
\begin{bmatrix}
  1 & 1 \\
  1 & 0
\end{bmatrix}^{n-1}$$


